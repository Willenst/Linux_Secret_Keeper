# Журнал Работ

### Техническое задание

1. Написать модуль ядра Linux для хранения секретов. Этот драйвер должен создавать специальный файл в procfs. С помощью этого интерфейса пользователь должен иметь возможность сохранить секрет в ядре (некоторые произвольные данные), прочитать секрет, удалить секрет. Для этого каждой порции секретных данных должен назначаться идентификатор.
2. Добить userspace-программу для тестирования драйвера
3. (По возможности) Собать ядро Linux и свой модуль с поддержкой KASAN, запустить userspace-тест и попробовать обнаружить ошибки доступа к памяти в коде. Если таких нет, то намеренно добавить ошибку доступа к памяти в свой модуль ядра и поймать ее с помощью KASAN.
4. (По возможности) Перевести созданный мной материал на английский язык для донесения до международного опенсорс комьюнити

### Предисловие

Опыта использования что Си, Что Си подобных языков у меня никогда не было, данный проект модуля ядра будет не просто первым моим модулем ядра, а еще и в целом первым моим проектом на Си. Наверное весьма уникальный случай - начать изучать язык с не с базовых задачек, а сразу с программирования модулей ядра. Так что, возможно на создание кода уйдет немного больше времени, чем нужно, и будет он не самого высокого качества, но эксперимент получится крайне интересный. Код будет постоянно переделываться с ростом моих навыков, которые на таких начальных этапах приобретаются крайне быстро, поскольку изначально я буду делать простенький каркас на основе методических материалов, а по мере понимания языка рефакторить и дополнять его - будет весьма интересна история версий. Данный журнал будет представлять мое погружение в замечательный мир низкоуровневых языков, действия будут выполнятся поэтапно, с построения базовых механизмов, и последующего дополнения их надстройками по расширению функционала.

Надеюсь, что первые части процесса разработки не вызовут у читателя непреодолимое желание закрыть журнал - они представляют собой не столько разработку, сколько мой процесс обучения и демонстрируют проделанную мной работу, но не конечный результат. 

### Часть 1. Хранилище на одну запись. **Linux_Secret_Keeper-v.0.01**

Поскольку procfs хранит в себе не фактические файлы, в привычном смысле этого понимания, а их эмуляцию, вернее даже сказать абстракцию, созданную для удобства и сохранения нервных клеток потенциальных разработчиков, нам нужно создать драйвер, который будет принимать системные вызовы чтения и записи, и возвращать какой то отклик в пользовательское пространство, это будет наш базовый функционал и наша первоочередная задача.

Начнем мы с организации необходимых нам файлов с макросами и определениями, указания общепринятой в сообществе GPL лицензии и своего авторства

```bash
#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/proc_fs.h>
#include <linux/uaccess.h>
MODULE_LICENSE("GPL");
MODULE_AUTHOR("Ratochka Vyacheslav");
MODULE_DESCRIPTION("A simple procfs storage module.");
MODULE_VERSION("0.01");
```

Далее - по классике, объявления переменных

```c
#define SECRET_SIZE 128 //максимальный размер секрета
#define PROCFS_NAME "secret_stash" //будущее название "файла" в procfs

static struct proc_dir_entry *storage_filename; //указатель под наш файл
static char storage[PROCFS_MAX_SIZE]; //непосредственно будущая "база"
static unsigned long storage_size = 0; //размер секрета, пока просто объявлен 0

```

Теперь нам необходима функция для чтения данных, все необходимые параметры ей будет передавать имеющийся практически во всех дистрибутивах системный вызов read.

```c
static ssize_t procfile_read(struct file *filePointer, char __user *buffer, size_t buffer_length, loff_t *offset)
{
    if (*offset >= SECRET_SIZE||copy_to_user(buffer, storage, SECRET_SIZE)) { 
        pr_info("fail!");
        return 0;
    }
    else{
        *offset += SECRET_SIZE;
    }
    return SECRET_SIZE;
}

```

Разберем данную функцию

```c
if (*offset >= SECRET_SIZE||copy_to_user(buffer, storage, SECRET_SIZE))
```

Фактически это алгоритм для чтения файла, есть проверка для указателя offset, он передается при вызове read и отвечает за текущий считываемый символ, как бы выступая указателем текущей позиции в файле. Когда он дойдет до конца файла - функция прервется, пока этого не произошло - файл считывается. 

Чтение на базовом уровне готово, теперь необходимо записывать

```c
static ssize_t procfile_write(struct file *file, const char __user *buff, size_t size, loff_t *off)
{
    newsecret_size = size;
    if (newsecret_size > SECRET_SIZE){
        newsecret_size = SECRET_SIZE;
    }
    if (copy_from_user(storage, buff, newsecret_size)){
        return -EFAULT; 
    }
    storage[newsecret_size & (SECRET_SIZE - 1)] = '\0';
    pr_info("procfile write %s\n", storage);
    return newsecret_size;
}

```

Данная функция также принимает все необходимые параметры от системных вызовов, тригернуть ее можно например следующей командой

```c
echo "secret" | tee /proc/secret_stash
```

В ней присутствует небольшая проверка на то, что подаваемый секрет не превышает допустимый размер, идет копирование входных данных из юзерспейса в наше хранилище, а также добавление символа конца файла `\0` в конец строки, в последствии логику нужно будет переделать, но как временное решение - вариант неплохой. 

 Далее, небольшой технический модуль под прием системных вызовов и направления их в соответствующие функции

```c
static const struct proc_ops proc_file_fops = {
    .proc_read = procfile_read,
    .proc_write = procfile_write,
};
```

Теперь нам необходим функционал инициализации

```c
static int __init procfs2_init(void)
{
    storage_filename = proc_create(PROCFS_NAME, 0644, NULL, &proc_file_fops);
    if (NULL == storage_filename) {
    proc_remove(storage_filename);
    pr_alert("Error:Could not initialize /proc/%s\n", PROCFS_NAME);
    return -ENOMEM;
    }
    pr_info("/proc/%s created\n", PROCFS_NAME);
    printk(KERN_INFO "Hello, World!\n");
    return 0;
}
```

Он будет создавать сущность в procfs, удалять ее в случае, если процесс создания завершился ошибкой и возвращать 0 в случае успеха

Также нам необходим завершающий модуль

```c
static void __exit procfs2_exit(void)
{
    proc_remove(storage_filename);
    pr_info("/proc/%s removed\n", PROCFS_NAME);
    printk(KERN_INFO "Goodbye, World!\n");
}
```

тут все достаточно прост - удаление нашего драйвера и вывод сообщения об этом, в конце кода добавляем следующую конструкцию и наша первая вариация можно сказать готова

```c
module_init(procfs2_init);
module_exit(procfs2_exit);
```

Работать с текущим кодом можно следующим образом

```bash
echo "secret" | tee /proc/secret_stash #запись
cat /proc/secret_stash #чтение
```

### Часть 2. Секретный массив. **Linux_Secret_Keeper-v.0.07**

Поскольку сам код растет, я буду приводить далее в основном ключевые изменения, с полными можно ознакомится в истории коммитов. 

Ну что ж, с хранением одной строчки мы разобрались, теперь нам нужно решить задачу хранения нескольких наборов данных, и их идентификации. Наилучшим образом на мой взгляд тут подойдет массив. Но просто ложить туда строчки будет не очень удобно, поскольку операция удаления потребует каждый раз их либо сдвигать, либо перезатирать нулями, все это будет захламлять память и вызывать море неудобств. Потому было решено создать отдельную простенькую структуру

```bash
struct secret {
    int id;
    char data[SECRET_SIZE];
};
```

Также переделаем наше хранилище в массив

```bash
static static storage[PROCFS_MAX_SIZE];
```

И добавим отдельный буфер под текущий секрет

```bash
static char secret_buf[SECRET_SIZE];
```

Теперь нам необходим еще и парсер

```bash
sscanf(secret_buffer, "%c %d %s", &command, &id, secret_data
```

Данный парсер послужит основой для построения 3-х базовых режимов модуля - чтение, запись и удаление. Он будет считывать режим и id записи, теперь нам очевидно необходимо создать надстройку - обработчик.

```c
        case 'W':
            if (next_id >= MAX_SECRETS||id > next_id)
                return -ENOMEM;
            storage[next_id].secret_id = next_id;
            strscpy(storage[next_id].secret_data, secret_data, newsecret_size);
            next_id++;
            return newsecret_size;
```

Данный модуль будет копировать пользовательский ввод напрямую в заданный индекс хранилища

```c
        case 'R':
            if (id > next_id)
                return -ENOMEM;
            read_index = id;
            pr_info("current index %s\n", id);
            return newsecret_size;
```

С модулем чтения все несколько по иному. Поскольку нам драйвер работает с системными вызовами, а системным вызовам неизвестно сколько строчек нужно читать - они будут читать пока драйвер их отдает. Так что, данный модуль отвечает за то, какую строчку будет отдавать наш драйвер. 

```
        case 'D':
            if (id<0||id > next_id)
                return -EINVAL;
            for (int i = id; i < next_id - 1; ++i) {
                storage[i] = storage[i + 1];
            }
            next_id--;
```

Ну и наконец - модуль удаления, который на самом деле сейчас не очень то рабочий и скорее носит характер “костыля”, он не учитывает случай удаления последней записи, так что при необходимости ее удалить - нужно выдумать новый секрет. Я оставил этот модуль как некую затычку, поскольку пока его делал, узнал что в ядре есть целая система макросов под работу с массивами, которая показалась мне гораздо удобнее, чем попытки как то перезатирать память массива. Само собой, я буду проводить его рефакторинг. 

Теперь поговорим о нашем новеньком модуле чтения. Он был полностью удален, написан, удален и написан снова, это можно видеть в истории коммитов, но что бы не плодить в журнале все свои ошибки, дам финальный вариант для текущей версии сборки 

```c
static ssize_t procfile_read(struct file *filePointer, char __user *buffer, size_t buffer_length, loff_t *offset)
{
    int i;
    char output_buffer[MAX_SECRET_SIZE*(next_id+1)];
    char temp_buffer[MAX_SECRET_SIZE];
    if (read_index == -1){
            for (i = 0; i < next_id; i++) {
                sprintf(temp_buffer, "%d. %s\n",storage[i].secret_id,storage[i].secret_data);
                strcat(output_buffer,temp_buffer);
            }
            if (*offset >= MAX_SECRET_SIZE||copy_to_user(buffer, output_buffer, MAX_SECRET_SIZE)) { 
                pr_info("fail!");
                return 0;
            }
            else{
                *offset += MAX_SECRET_SIZE;
            }

        return MAX_SECRET_SIZE;
            }
    else{
        sprintf(temp_buffer, "%d. %s\n",storage[read_index].secret_id,storage[read_index].secret_data);
        if (*offset >= MAX_SECRET_SIZE||copy_to_user(buffer, temp_buffer, MAX_SECRET_SIZE)) { 
            pr_info("fail!");
            return 0;
        }
        else{
            *offset += MAX_SECRET_SIZE;
        }
        return MAX_SECRET_SIZE;
        }
    return MAX_SECRET_SIZE;
}

```

Модуль серьезно так прибавил размера и веса, теперь он мало того, что работает в двух режимах, на вывод всех данных, и вывод какой то конкретной их части, так еще и выводит их идентификатор, что на мой взгляд очень помогает в визуализации рабочего процесса. Возможно позже я скину эту задачу на userspace программу, но пока так гораздо удобнее проводить дебаг кода. 

Все это было протестировано именно на “правильное” использование, которое описано в документации, сейчас у нас имеется весьма костыльное и неказистое решение, но в целом - делающее саму задачу. Драйвер пишет, драйвер читает, драйвер удаляет, драйвер делает это все с применением идентификаторов. 

### Часть 3. Макросы и проверки. **Linux_Secret_Keeper-v.0.02**

Итак, наш код начал обретать кое-какой функционал, а я смотрю на код, и для меня он перестает выглядеть как какой то абстрактный набор символов, а с пониманием языка приходит и осознание, осознание несовершенства своей программы, наличия множества ошибок, хочется сделать код лучше, надежнее, красивее. Данная часть будет посвящена этому аспекту.

Пожалуй наиболее главный аспект текущего кода - работа со списком данных, ее будем полностью перекладывать на макрос, который во первых - удобнее, во вторых - разработан специально под создание модулей ядра.

```c
struct secret{
    int secret_id;
    char secret_data[MAX_SECRET_SIZE];
    struct list_head list_node; //переделка списка под макрос
};

LIST_HEAD(secret); //переделка списка под макрос
```

Далее, введем функцию проверки вхождения

```
static bool secret_finder(int id, struct list_head *secrets) {
    struct list_head *pos;

    list_for_each(pos, secrets) {
        secret_t *p = list_entry(pos, secret_t, list_node);
        if (p->secret_id == id) {
            return true;
        }
    }
    return false;
}

```

Это бинарная функция, которая проверяет имеется ли элемент в нашем списке, или нет, далее будем использовать под переделку операций.

Итак, переделываем все три функции под новый стандарт, запись:

```c
        case 'W':
            if (next_id >= MAX_SECRETS)
                return -ENOMEM;
            if (secret_finder(id, &secrets))
                return -EINVAL;
            secret_t* new_secret = (secret_t*)kmalloc(sizeof(secret_t), GFP_KERNEL);
            new_secret->secret_id = id;
            strscpy(new_secret->secret_data, secret_data, MAX_SECRET_SIZE);        
            list_add_tail(&new_secret->list_node, &secrets);
            next_id++;
            return newsecret_size;
```

Тут практически полностью изменилась вся структура, теперь мы работаем с надстроенным сверху списком и его заголовками, это занимает больше строчек кода, но в перспективе - сэкономит много нервов и сделает код куда проще что в чтении, что в доработке. А самое главное - больше никакой физической привязки id секрета в его позиции в массиве, возможно стоит добавить возможность не указывать id вовсе, но если это и будет сделано, то только после того, как программа обзаведется нормальным тестированием, поскольку код раз за разом перепиливается, и обрастает новыми возможностями, проверять все ручками - несколько утомляет. 

Чтение:

```c
        case 'R':
            if (id == -1)
            {
                read_index = id;
                return newsecret_size;
            }
            if (secret_finder(id, &secrets)){
                read_index = id;
                return newsecret_size;
            }
            return -EINVAL;
```

Функция чтения была также переработана, она расширилась, в ней появилась проверка на нахождение читаемого элемента в списке.

Удаление:

```c
        case 'D':
            if (next_id<1)
                return -EINVAL;
            list_for_each_safe(pos, tmp, &secrets) {
                secret_t* p = list_entry(pos, secret_t, list_node);
                if (p->secret_id == id) {
                    list_del(pos);
                    kfree(p);
                    deleted=true;
                }
            }
            if (deleted==true){
            next_id--;
            return newsecret_size;
            }
            return -EINVAL;
```

Прощайте костыли с перезаписыванием элементов и здравствуй полноценное удаление, макрос несет все больше пользы, и теперь удаление наконец стало полноценным удалением. Также на основе макроса была переделана функция чтения (не режим, именно функция), но там фактических изменений не так много, просто переделка, они будут в коммитах.